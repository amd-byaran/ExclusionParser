/**
 * @file test_parser.cpp
 * @brief Tests for the ExclusionParser class
 * 
 * This file contains unit tests for the parser functionality,
 * including parsing various exclusion formats and handling edge cases.
 * 
 * @author ExclusionCoverageParser
 * @version 1.0.0
 * @date 2025
 */

#include <gtest/gtest.h>
#include "ExclusionParser.h"
#include <sstream>

using namespace ExclusionParser;

/**
 * @brief Test fixture for parser tests
 */
class ParserTest : public ::testing::Test {
protected:
    void SetUp() override {
        parser = std::make_unique<ExclusionParser>();
        
        // Sample exclusion file content for testing
        sampleContent = R"(//==================================================
// This file contains the Excluded objects
// Generated By User: test_user
// Format Version: 2
// Date: Mon Jan 01 00:00:00 2025
// ExclMode: test
//==================================================
CHECKSUM: "123456789"
INSTANCE: tb.test.module.instance
ANNOTATION: "Test block exclusion"
Block 161 "1104666086" "do_db_reg_update = 1'b0;"
ANNOTATION: "Test toggle exclusion"
Toggle 1to0 test_signal "net test_signal"
Toggle test_vector [5] "net test_vector[7:0]"
CHECKSUM: "987654321"
MODULE: test_module
Fsm test_state "85815111"
ANNOTATION: "Test transition"
Transition IDLE->ACTIVE "0->1"
Condition 2 "2940925445" "(signal_a && signal_b) 1 -1" (1 "01")
)";
    }
    
    void TearDown() override {
        parser.reset();
    }
    
    std::unique_ptr<ExclusionParser> parser;
    std::string sampleContent;
};

/**
 * @brief Test basic parser construction and configuration
 */
TEST_F(ParserTest, BasicConstruction) {
    EXPECT_TRUE(parser != nullptr);
    EXPECT_FALSE(parser->hasData());
    EXPECT_FALSE(parser->isDebugMode());
    
    // Test configuration
    ParserConfig config;
    config.strictMode = true;
    config.validateChecksums = false;
    parser->setConfig(config);
    
    const auto& retrievedConfig = parser->getConfig();
    EXPECT_TRUE(retrievedConfig.strictMode);
    EXPECT_FALSE(retrievedConfig.validateChecksums);
}

/**
 * @brief Test parsing from string content
 */
TEST_F(ParserTest, ParseFromString) {
    auto result = parser->parseString(sampleContent, "test_string");
    
    EXPECT_TRUE(result.success) << "Parse failed: " << result.errorMessage;
    EXPECT_GT(result.linesProcessed, 0);
    EXPECT_GT(result.exclusionsParsed, 0);
    
    // Check that we have the expected exclusion types
    EXPECT_GT(result.exclusionCounts[ExclusionType::BLOCK], 0);
    EXPECT_GT(result.exclusionCounts[ExclusionType::TOGGLE], 0);
    EXPECT_GT(result.exclusionCounts[ExclusionType::FSM], 0);
    EXPECT_GT(result.exclusionCounts[ExclusionType::CONDITION], 0);
    
    // Verify data was parsed correctly
    EXPECT_TRUE(parser->hasData());
    auto data = parser->getData();
    EXPECT_EQ(data->generatedBy, "test_user");
    EXPECT_EQ(data->formatVersion, "2");
    EXPECT_EQ(data->exclusionMode, "test");
    
    // Check scopes
    EXPECT_EQ(data->getScopeCount(), 2);
    EXPECT_TRUE(data->scopes.find("tb.test.module.instance") != data->scopes.end());
    EXPECT_TRUE(data->scopes.find("test_module") != data->scopes.end());
    
    // Check specific exclusions
    auto& instanceScope = data->scopes["tb.test.module.instance"];
    EXPECT_FALSE(instanceScope.isModule);
    EXPECT_GT(instanceScope.blockExclusions.size(), 0);
    EXPECT_GT(instanceScope.toggleExclusions.size(), 0);
    
    auto& moduleScope = data->scopes["test_module"];
    EXPECT_TRUE(moduleScope.isModule);
    EXPECT_GT(moduleScope.fsmExclusions.size(), 0);
    EXPECT_GT(moduleScope.conditionExclusions.size(), 0);
}

/**
 * @brief Test parsing block exclusions specifically
 */
TEST_F(ParserTest, ParseBlockExclusions) {
    std::string blockContent = R"(
CHECKSUM: "123456"
INSTANCE: test.instance
ANNOTATION: "Legacy code"
Block 161 "1104666086" "do_db_reg_update = 1'b0;"
Block 402 "2338675172" "bl_on <= 1'b1;"
)";
    
    auto result = parser->parseString(blockContent, "block_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::BLOCK], 2);
    
    auto data = parser->getData();
    auto& scope = data->scopes["test.instance"];
    
    EXPECT_EQ(scope.blockExclusions.size(), 2);
    EXPECT_TRUE(scope.blockExclusions.find("161") != scope.blockExclusions.end());
    EXPECT_TRUE(scope.blockExclusions.find("402") != scope.blockExclusions.end());
    
    auto& block161 = scope.blockExclusions["161"];
    EXPECT_EQ(block161.checksum, "1104666086");
    EXPECT_EQ(block161.sourceCode, "do_db_reg_update = 1'b0;");
    EXPECT_EQ(block161.annotation, "Legacy code");
}

/**
 * @brief Test parsing toggle exclusions specifically
 */
TEST_F(ParserTest, ParseToggleExclusions) {
    std::string toggleContent = R"(
CHECKSUM: "123456"
INSTANCE: test.instance
ANNOTATION: "Toggle test"
Toggle 1to0 signal_carry "net signal_carry"
Toggle 0to1 signal_data "net signal_data"
Toggle signal_array [16] "net signal_array[31:0]"
Toggle signal_simple "net signal_simple"
)";
    
    auto result = parser->parseString(toggleContent, "toggle_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::TOGGLE], 4);
    
    auto data = parser->getData();
    auto& scope = data->scopes["test.instance"];
    
    EXPECT_EQ(scope.toggleExclusions.size(), 4);
    
    // Check specific toggles
    EXPECT_TRUE(scope.toggleExclusions.find("signal_carry") != scope.toggleExclusions.end());
    auto& carryToggles = scope.toggleExclusions["signal_carry"];
    EXPECT_EQ(carryToggles.size(), 1);
    EXPECT_EQ(carryToggles[0].direction, ToggleDirection::ONE_TO_ZERO);
    EXPECT_EQ(carryToggles[0].annotation, "Toggle test");
    
    EXPECT_TRUE(scope.toggleExclusions.find("signal_array") != scope.toggleExclusions.end());
    auto& arrayToggles = scope.toggleExclusions["signal_array"];
    EXPECT_EQ(arrayToggles.size(), 1);
    EXPECT_TRUE(arrayToggles[0].bitIndex.has_value());
    EXPECT_EQ(arrayToggles[0].bitIndex.value(), 16);
}

/**
 * @brief Test parsing FSM exclusions specifically
 */
TEST_F(ParserTest, ParseFsmExclusions) {
    std::string fsmContent = R"(
CHECKSUM: "123456"
MODULE: test_module
Fsm state "85815111"
ANNOTATION: "Reset transition"
Transition SND_RD_ADDR1->IDLE "11->0"
Transition SND_WR_CMD->IDLE "1->0"
Fsm req_state "4079565410"
)";
    
    auto result = parser->parseString(fsmContent, "fsm_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::FSM], 4);
    
    auto data = parser->getData();
    auto& scope = data->scopes["test_module"];
    
    EXPECT_TRUE(scope.isModule);
    
    // Check state exclusions
    EXPECT_TRUE(scope.fsmExclusions.find("state") != scope.fsmExclusions.end());
    auto& stateExclusions = scope.fsmExclusions["state"];
    EXPECT_GE(stateExclusions.size(), 1);
    
    // Find the state exclusion (not transition)
    bool foundState = false;
    for (const auto& fsm : stateExclusions) {
        if (!fsm.isTransition) {
            EXPECT_EQ(fsm.checksum, "85815111");
            foundState = true;
            break;
        }
    }
    EXPECT_TRUE(foundState);
    
    // Check transition exclusions
    EXPECT_TRUE(scope.fsmExclusions.find("transition") != scope.fsmExclusions.end());
    auto& transitionExclusions = scope.fsmExclusions["transition"];
    EXPECT_GE(transitionExclusions.size(), 2);
    
    // Find specific transition
    bool foundTransition = false;
    for (const auto& fsm : transitionExclusions) {
        if (fsm.isTransition && fsm.fromState == "SND_RD_ADDR1" && fsm.toState == "IDLE") {
            EXPECT_EQ(fsm.transitionId, "11->0");
            EXPECT_EQ(fsm.annotation, "Reset transition");
            foundTransition = true;
            break;
        }
    }
    EXPECT_TRUE(foundTransition);
}

/**
 * @brief Test parsing condition exclusions specifically
 */
TEST_F(ParserTest, ParseConditionExclusions) {
    std::string conditionContent = R"(
CHECKSUM: "123456"
INSTANCE: test.instance
ANNOTATION: "Impossible condition"
Condition 2 "2940925445" "(signal_a && (signal_b != 2'b0)) 1 -1" (1 "01")
Condition 7 "4114727016" "(signal_c || signal_d) 2 -1" (2 "10")
)";
    
    auto result = parser->parseString(conditionContent, "condition_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::CONDITION], 2);
    
    auto data = parser->getData();
    auto& scope = data->scopes["test.instance"];
    
    EXPECT_EQ(scope.conditionExclusions.size(), 2);
    EXPECT_TRUE(scope.conditionExclusions.find("2") != scope.conditionExclusions.end());
    EXPECT_TRUE(scope.conditionExclusions.find("7") != scope.conditionExclusions.end());
    
    auto& condition2 = scope.conditionExclusions["2"];
    EXPECT_EQ(condition2.checksum, "2940925445");
    EXPECT_TRUE(condition2.expression.find("signal_a && (signal_b != 2'b0)") != std::string::npos);
    EXPECT_EQ(condition2.coverage, "1 \"01\"");
    EXPECT_EQ(condition2.annotation, "Impossible condition");
}

/**
 * @brief Test error handling for malformed content
 */
TEST_F(ParserTest, ErrorHandling) {
    // Test with invalid content
    std::string invalidContent = R"(
This is not a valid exclusion file
Invalid line format
Block without proper format
)";
    
    ParserConfig config;
    config.strictMode = false; // Allow parsing to continue with warnings
    parser->setConfig(config);
    
    auto result = parser->parseString(invalidContent, "invalid_test");
    
    // Should succeed but with warnings in non-strict mode
    EXPECT_TRUE(result.success);
    EXPECT_GT(result.warnings.size(), 0);
    
    // Test strict mode
    config.strictMode = true;
    parser->setConfig(config);
    parser->clear();
    
    result = parser->parseString(invalidContent, "invalid_strict_test");
    
    // Should fail in strict mode
    EXPECT_FALSE(result.success);
    EXPECT_FALSE(result.errorMessage.empty());
}

/**
 * @brief Test parsing from stream
 */
TEST_F(ParserTest, ParseFromStream) {
    std::istringstream stream(sampleContent);
    
    auto result = parser->parseStream(stream, "stream_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_GT(result.exclusionsParsed, 0);
    EXPECT_TRUE(parser->hasData());
}

/**
 * @brief Test multi-line annotations
 */
TEST_F(ParserTest, MultiLineAnnotations) {
    std::string multilineContent = R"(
CHECKSUM: "123456"
INSTANCE: test.instance
ANNOTATION_BEGIN: "This is a multi-line annotation"
Block 1 "123" "test_code = 1'b0;"
ANNOTATION_END
ANNOTATION: "Single line annotation"
Block 2 "456" "another_code = 1'b1;"
)";
    
    auto result = parser->parseString(multilineContent, "multiline_test");
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::BLOCK], 2);
    
    auto data = parser->getData();
    auto& scope = data->scopes["test.instance"];
    
    auto& block1 = scope.blockExclusions["1"];
    EXPECT_EQ(block1.annotation, "This is a multi-line annotation");
    
    auto& block2 = scope.blockExclusions["2"];
    EXPECT_EQ(block2.annotation, "Single line annotation");
}

/**
 * @brief Test data manager integration
 */
TEST_F(ParserTest, DataManagerIntegration) {
    auto result = parser->parseString(sampleContent, "manager_test");
    EXPECT_TRUE(result.success);
    
    auto& manager = parser->getDataManager();
    
    // Test search functionality
    SearchCriteria criteria;
    criteria.type = ExclusionType::BLOCK;
    auto searchResults = manager.search(criteria);
    EXPECT_GT(searchResults.size(), 0);
    
    // Test statistics
    auto stats = manager.getStatistics();
    EXPECT_GT(stats.totalExclusions, 0);
    EXPECT_GT(stats.totalScopes, 0);
    
    // Test scope finding
    auto scope = manager.findScope("tb.test.module.instance");
    EXPECT_TRUE(scope != nullptr);
    EXPECT_FALSE(scope->isModule);
}

/**
 * @brief Test debug mode functionality
 */
TEST_F(ParserTest, DebugMode) {
    EXPECT_FALSE(parser->isDebugMode());
    
    parser->setDebugMode(true);
    EXPECT_TRUE(parser->isDebugMode());
    
    // Parse with debug mode (should not affect functionality)
    auto result = parser->parseString(sampleContent, "debug_test");
    EXPECT_TRUE(result.success);
    
    parser->setDebugMode(false);
    EXPECT_FALSE(parser->isDebugMode());
}

/**
 * @brief Test file validation
 */
TEST_F(ParserTest, FileValidation) {
    // Test validation of non-existent file
    EXPECT_FALSE(parser->validateFile("non_existent_file.el"));
    
    // Create a temporary file for testing
    std::string tempFilename = "temp_test.el";
    std::ofstream tempFile(tempFilename);
    tempFile << sampleContent;
    tempFile.close();
    
    // Test validation of valid file
    EXPECT_TRUE(parser->validateFile(tempFilename));
    
    // Clean up
    std::remove(tempFilename.c_str());
}

/**
 * @brief Test merge functionality
 */
TEST_F(ParserTest, MergeFunctionality) {
    // Parse first content
    auto result1 = parser->parseString(sampleContent, "merge_test1");
    EXPECT_TRUE(result1.success);
    
    size_t originalCount = parser->getData()->getTotalExclusionCount();
    
    // Create additional content
    std::string additionalContent = R"(
CHECKSUM: "999888"
INSTANCE: tb.test.additional.instance
Block 999 "888777" "additional_code = 1'b0;"
)";
    
    // Enable merge mode
    ParserConfig config = parser->getConfig();
    config.mergeOnLoad = true;
    parser->setConfig(config);
    
    // Parse additional content
    auto result2 = parser->parseString(additionalContent, "merge_test2");
    EXPECT_TRUE(result2.success);
    
    // Check that data was merged
    size_t newCount = parser->getData()->getTotalExclusionCount();
    EXPECT_GT(newCount, originalCount);
    
    // Verify the new scope exists
    EXPECT_TRUE(parser->getData()->scopes.find("tb.test.additional.instance") != 
                parser->getData()->scopes.end());
}