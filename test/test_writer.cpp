/**
 * @file test_writer.cpp
 * @brief Tests for the ExclusionWriter class
 * 
 * This file contains unit tests for the writer functionality,
 * including writing various exclusion formats and round-trip testing.
 * 
 * @author ExclusionCoverageParser
 * @version 1.0.0
 * @date 2025
 */

#include <gtest/gtest.h>
#include "ExclusionWriter.h"
#include "ExclusionParser.h"
#include <sstream>
#include <fstream>

using namespace ExclusionParser;

/**
 * @brief Test fixture for writer tests
 */
class WriterTest : public ::testing::Test {
protected:
    void SetUp() override {
        writer = std::make_unique<ExclusionWriter>();
        parser = std::make_unique<ExclusionParser>();
        
        // Create sample test data
        testData = std::make_shared<ExclusionData>("test.el");
        testData->generatedBy = "test_user";
        testData->formatVersion = "2";
        testData->generationDate = "Mon Jan 01 00:00:00 2025";
        testData->exclusionMode = "test";
        
        // Add test scopes and exclusions
        setupTestData();
    }
    
    void TearDown() override {
        writer.reset();
        parser.reset();
    }
    
    void setupTestData() {
        // Instance scope with various exclusions
        auto& instanceScope = testData->getOrCreateScope("tb.test.module.instance", "123456", false);
        
        // Block exclusions
        BlockExclusion block1("161", "1104666086", "do_db_reg_update = 1'b0;", "Legacy code");
        BlockExclusion block2("402", "2338675172", "bl_on <= 1'b1;", "");
        instanceScope.addBlockExclusion(block1);
        instanceScope.addBlockExclusion(block2);
        
        // Toggle exclusions
        ToggleExclusion toggle1(ToggleDirection::ONE_TO_ZERO, "signal_carry", std::nullopt, 
                               "net signal_carry", "Toggle test");
        ToggleExclusion toggle2(ToggleDirection::ZERO_TO_ONE, "signal_data", std::nullopt, 
                               "net signal_data", "");
        ToggleExclusion toggle3(ToggleDirection::BOTH, "signal_array", 16, 
                               "net signal_array[31:0]", "Array bit toggle");
        instanceScope.addToggleExclusion(toggle1);
        instanceScope.addToggleExclusion(toggle2);
        instanceScope.addToggleExclusion(toggle3);
        
        // Module scope with FSM and condition exclusions
        auto& moduleScope = testData->getOrCreateScope("test_module", "987654", true);
        
        // FSM exclusions
        FsmExclusion fsm1("state", "85815111", "FSM state test");
        FsmExclusion fsm2("transition", "IDLE", "ACTIVE", "0->1", "Reset transition");
        moduleScope.addFsmExclusion(fsm1);
        moduleScope.addFsmExclusion(fsm2);
        
        // Condition exclusions
        ConditionExclusion condition1("2", "2940925445", "signal_a && signal_b", "1 -1", 
                                     "1 \"01\"", "Impossible condition");
        moduleScope.addConditionExclusion(condition1);
    }
    
    std::unique_ptr<ExclusionWriter> writer;
    std::unique_ptr<ExclusionParser> parser;
    std::shared_ptr<ExclusionData> testData;
};

/**
 * @brief Test basic writer construction and configuration
 */
TEST_F(WriterTest, BasicConstruction) {
    EXPECT_TRUE(writer != nullptr);
    EXPECT_FALSE(writer->isDebugMode());
    
    // Test configuration
    WriterConfig config;
    config.sortExclusions = true;
    config.includeAnnotations = false;
    writer->setConfig(config);
    
    const auto& retrievedConfig = writer->getConfig();
    EXPECT_TRUE(retrievedConfig.sortExclusions);
    EXPECT_FALSE(retrievedConfig.includeAnnotations);
}

/**
 * @brief Test writing to string
 */
TEST_F(WriterTest, WriteToString) {
    std::string output = writer->writeToString(*testData);
    
    EXPECT_FALSE(output.empty());
    
    // Check for header content
    EXPECT_TRUE(output.find("This file contains the Excluded objects") != std::string::npos);
    EXPECT_TRUE(output.find("Generated By User: test_user") != std::string::npos);
    EXPECT_TRUE(output.find("Format Version: 2") != std::string::npos);
    
    // Check for scope declarations
    EXPECT_TRUE(output.find("INSTANCE:tb.test.module.instance") != std::string::npos);
    EXPECT_TRUE(output.find("MODULE:test_module") != std::string::npos);
    
    // Check for exclusion content
    EXPECT_TRUE(output.find("Block 161") != std::string::npos);
    EXPECT_TRUE(output.find("Toggle 1to0 signal_carry") != std::string::npos);
    EXPECT_TRUE(output.find("Fsm state") != std::string::npos);
    EXPECT_TRUE(output.find("Condition 2") != std::string::npos);
}

/**
 * @brief Test writing to stream
 */
TEST_F(WriterTest, WriteToStream) {
    std::ostringstream oss;
    auto result = writer->writeToStream(oss, *testData);
    
    EXPECT_TRUE(result.success) << "Write failed: " << result.errorMessage;
    EXPECT_GT(result.linesWritten, 0);
    EXPECT_GT(result.exclusionsWritten, 0);
    EXPECT_EQ(result.scopesWritten, 2);
    
    // Check exclusion counts
    EXPECT_EQ(result.exclusionCounts[ExclusionType::BLOCK], 2);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::TOGGLE], 3);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::FSM], 2);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::CONDITION], 1);
    
    std::string output = oss.str();
    EXPECT_FALSE(output.empty());
}

/**
 * @brief Test writing to file
 */
TEST_F(WriterTest, WriteToFile) {
    std::string filename = "test_output.el";
    
    auto result = writer->writeFile(filename, *testData);
    
    EXPECT_TRUE(result.success) << "Write failed: " << result.errorMessage;
    EXPECT_GT(result.exclusionsWritten, 0);
    
    // Verify file was created and has content
    std::ifstream file(filename);
    EXPECT_TRUE(file.is_open());
    
    std::string content((std::istreambuf_iterator<char>(file)),
                        std::istreambuf_iterator<char>());
    EXPECT_FALSE(content.empty());
    
    file.close();
    
    // Clean up
    std::remove(filename.c_str());
}

/**
 * @brief Test round-trip parsing and writing
 */
TEST_F(WriterTest, RoundTripTest) {
    // Write data to string
    std::string written = writer->writeToString(*testData);
    EXPECT_FALSE(written.empty());
    
    // Parse the written data back
    auto parseResult = parser->parseString(written, "roundtrip_test");
    EXPECT_TRUE(parseResult.success) << "Parse failed: " << parseResult.errorMessage;
    
    auto parsedData = parser->getData();
    
    // Compare key properties
    EXPECT_EQ(parsedData->generatedBy, testData->generatedBy);
    EXPECT_EQ(parsedData->formatVersion, testData->formatVersion);
    EXPECT_EQ(parsedData->exclusionMode, testData->exclusionMode);
    EXPECT_EQ(parsedData->getScopeCount(), testData->getScopeCount());
    
    // Compare exclusion counts
    auto originalCounts = testData->getExclusionCountsByType();
    auto parsedCounts = parsedData->getExclusionCountsByType();
    
    EXPECT_EQ(parsedCounts[ExclusionType::BLOCK], originalCounts[ExclusionType::BLOCK]);
    EXPECT_EQ(parsedCounts[ExclusionType::TOGGLE], originalCounts[ExclusionType::TOGGLE]);
    EXPECT_EQ(parsedCounts[ExclusionType::FSM], originalCounts[ExclusionType::FSM]);
    EXPECT_EQ(parsedCounts[ExclusionType::CONDITION], originalCounts[ExclusionType::CONDITION]);
    
    // Verify specific exclusions
    EXPECT_TRUE(parsedData->scopes.find("tb.test.module.instance") != parsedData->scopes.end());
    EXPECT_TRUE(parsedData->scopes.find("test_module") != parsedData->scopes.end());
    
    auto& instanceScope = parsedData->scopes["tb.test.module.instance"];
    EXPECT_FALSE(instanceScope.isModule);
    EXPECT_EQ(instanceScope.blockExclusions.size(), 2);
    EXPECT_EQ(instanceScope.toggleExclusions.size(), 3);
    
    auto& moduleScope = parsedData->scopes["test_module"];
    EXPECT_TRUE(moduleScope.isModule);
    EXPECT_EQ(moduleScope.fsmExclusions.size(), 2);
    EXPECT_EQ(moduleScope.conditionExclusions.size(), 1);
}

/**
 * @brief Test writing with different configurations
 */
TEST_F(WriterTest, ConfigurationOptions) {
    // Test without comments
    WriterConfig config;
    config.includeComments = false;
    config.includeAnnotations = false;
    writer->setConfig(config);
    
    std::string outputNoComments = writer->writeToString(*testData);
    EXPECT_FALSE(outputNoComments.find("This file contains the Excluded objects") != std::string::npos);
    EXPECT_FALSE(outputNoComments.find("ANNOTATION:") != std::string::npos);
    
    // Test with sorting
    config.includeComments = true;
    config.includeAnnotations = true;
    config.sortExclusions = true;
    writer->setConfig(config);
    
    std::string outputSorted = writer->writeToString(*testData);
    EXPECT_FALSE(outputSorted.empty());
    
    // Test compact format
    config.compactFormat = true;
    config.lineEnding = "\n";
    writer->setConfig(config);
    
    std::string outputCompact = writer->writeToString(*testData);
    EXPECT_FALSE(outputCompact.empty());
}

/**
 * @brief Test writing specific scopes only
 */
TEST_F(WriterTest, WriteSpecificScopes) {
    std::string filename = "test_scopes.el";
    std::vector<std::string> scopesToWrite = {"tb.test.module.instance"};
    
    auto result = writer->writeScopes(filename, *testData, scopesToWrite);
    
    EXPECT_TRUE(result.success);
    EXPECT_EQ(result.scopesWritten, 1);
    
    // Parse back and verify only one scope
    std::ifstream file(filename);
    std::string content((std::istreambuf_iterator<char>(file)),
                        std::istreambuf_iterator<char>());
    file.close();
    
    EXPECT_TRUE(content.find("INSTANCE:tb.test.module.instance") != std::string::npos);
    EXPECT_FALSE(content.find("MODULE:test_module") != std::string::npos);
    
    // Clean up
    std::remove(filename.c_str());
}

/**
 * @brief Test writing filtered by exclusion type
 */
TEST_F(WriterTest, WriteFilteredByType) {
    std::string filename = "test_filtered.el";
    std::vector<ExclusionType> typesToWrite = {ExclusionType::BLOCK, ExclusionType::TOGGLE};
    
    auto result = writer->writeFilteredByType(filename, *testData, typesToWrite);
    
    EXPECT_TRUE(result.success);
    EXPECT_GT(result.exclusionCounts[ExclusionType::BLOCK], 0);
    EXPECT_GT(result.exclusionCounts[ExclusionType::TOGGLE], 0);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::FSM], 0);
    EXPECT_EQ(result.exclusionCounts[ExclusionType::CONDITION], 0);
    
    // Parse back and verify filtering
    auto parseResult = parser->parseFile(filename);
    EXPECT_TRUE(parseResult.success);
    
    EXPECT_GT(parseResult.exclusionCounts[ExclusionType::BLOCK], 0);
    EXPECT_GT(parseResult.exclusionCounts[ExclusionType::TOGGLE], 0);
    EXPECT_EQ(parseResult.exclusionCounts[ExclusionType::FSM], 0);
    EXPECT_EQ(parseResult.exclusionCounts[ExclusionType::CONDITION], 0);
    
    // Clean up
    std::remove(filename.c_str());
}

/**
 * @brief Test appending to existing file
 */
TEST_F(WriterTest, AppendToFile) {
    std::string filename = "test_append.el";
    
    // Create initial file with some content
    std::ofstream initialFile(filename);
    initialFile << "// Initial content\n";
    initialFile.close();
    
    // Append our data
    auto result = writer->appendToFile(filename, *testData);
    EXPECT_TRUE(result.success);
    
    // Read back and verify both initial content and appended data
    std::ifstream file(filename);
    std::string content((std::istreambuf_iterator<char>(file)),
                        std::istreambuf_iterator<char>());
    file.close();
    
    EXPECT_TRUE(content.find("Initial content") != std::string::npos);
    EXPECT_TRUE(content.find("INSTANCE:tb.test.module.instance") != std::string::npos);
    
    // Clean up
    std::remove(filename.c_str());
}

/**
 * @brief Test data validation before writing
 */
TEST_F(WriterTest, DataValidation) {
    // Test with valid data
    auto issues = writer->validateForWriting(*testData);
    EXPECT_TRUE(issues.empty());
    
    // Create invalid data
    ExclusionData invalidData;
    auto& scope = invalidData.getOrCreateScope("", "", false); // Empty scope name
    BlockExclusion invalidBlock("", "123", "code", ""); // Empty block ID
    scope.addBlockExclusion(invalidBlock);
    
    issues = writer->validateForWriting(invalidData);
    EXPECT_FALSE(issues.empty());
    EXPECT_GT(issues.size(), 0);
}

/**
 * @brief Test preview functionality
 */
TEST_F(WriterTest, PreviewFunctionality) {
    std::string preview = writer->preview(*testData, 10);
    
    EXPECT_FALSE(preview.empty());
    
    // Count lines in preview
    size_t lineCount = std::count(preview.begin(), preview.end(), '\n');
    EXPECT_LE(lineCount, 11); // Should be <= maxLines + 1 (for truncation message)
    
    // Full preview should contain more content
    std::string fullOutput = writer->writeToString(*testData);
    size_t fullLineCount = std::count(fullOutput.begin(), fullOutput.end(), '\n');
    
    if (fullLineCount > 10) {
        EXPECT_TRUE(preview.find("truncated") != std::string::npos);
    }
}

/**
 * @brief Test output size estimation
 */
TEST_F(WriterTest, OutputSizeEstimation) {
    size_t estimatedSize = writer->estimateOutputSize(*testData);
    EXPECT_GT(estimatedSize, 0);
    
    // Compare with actual output size
    std::string actualOutput = writer->writeToString(*testData);
    size_t actualSize = actualOutput.length();
    
    // Estimation should be in the right ballpark (within 50% of actual)
    EXPECT_GT(estimatedSize, actualSize / 2);
    EXPECT_LT(estimatedSize, actualSize * 2);
}

/**
 * @brief Test ExclusionFormatter functionality
 */
TEST_F(WriterTest, FormatterFunctionality) {
    // Test block formatting
    BlockExclusion block("161", "123456", "test_code = 1'b0;", "Test annotation");
    std::string formattedBlock = ExclusionFormatter::formatBlock(block, true);
    
    EXPECT_TRUE(formattedBlock.find("Block 161") != std::string::npos);
    EXPECT_TRUE(formattedBlock.find("test_code = 1'b0;") != std::string::npos);
    EXPECT_TRUE(formattedBlock.find("ANNOTATION:") != std::string::npos);
    
    // Test toggle formatting
    ToggleExclusion toggle(ToggleDirection::ONE_TO_ZERO, "signal", 5, "net signal[7:0]", "");
    std::string formattedToggle = ExclusionFormatter::formatToggle(toggle, false);
    
    EXPECT_TRUE(formattedToggle.find("Toggle 1to0 signal [5]") != std::string::npos);
    EXPECT_FALSE(formattedToggle.find("ANNOTATION:") != std::string::npos);
    
    // Test FSM formatting
    FsmExclusion fsm("test", "IDLE", "ACTIVE", "0->1", "Transition test");
    std::string formattedFsm = ExclusionFormatter::formatFsm(fsm, true);
    
    EXPECT_TRUE(formattedFsm.find("Transition IDLE->ACTIVE") != std::string::npos);
    EXPECT_TRUE(formattedFsm.find("ANNOTATION:") != std::string::npos);
    
    // Test condition formatting
    ConditionExclusion condition("2", "123", "expr", "params", "cov", "Test condition");
    std::string formattedCondition = ExclusionFormatter::formatCondition(condition, true);
    
    EXPECT_TRUE(formattedCondition.find("Condition 2") != std::string::npos);
    EXPECT_TRUE(formattedCondition.find("expr") != std::string::npos);
    
    // Test file header formatting
    std::string header = ExclusionFormatter::formatFileHeader(*testData);
    EXPECT_TRUE(header.find("Generated By User: test_user") != std::string::npos);
}

/**
 * @brief Test debug mode functionality
 */
TEST_F(WriterTest, DebugMode) {
    EXPECT_FALSE(writer->isDebugMode());
    
    writer->setDebugMode(true);
    EXPECT_TRUE(writer->isDebugMode());
    
    // Write with debug mode (should not affect functionality)
    auto result = writer->writeToStream(std::cout, *testData);
    EXPECT_TRUE(result.success);
    
    writer->setDebugMode(false);
    EXPECT_FALSE(writer->isDebugMode());
}

/**
 * @brief Test writing multiple files
 */
TEST_F(WriterTest, WriteMultipleFiles) {
    std::vector<std::shared_ptr<ExclusionData>> dataList;
    dataList.push_back(testData);
    
    // Create second data set
    auto testData2 = std::make_shared<ExclusionData>("test2.el");
    auto& scope2 = testData2->getOrCreateScope("additional.scope", "111222", false);
    BlockExclusion block("999", "888", "additional_code", "");
    scope2.addBlockExclusion(block);
    dataList.push_back(testData2);
    
    std::string baseFilename = "test_multi.el";
    auto result = writer->writeMultipleFiles(baseFilename, dataList);
    
    EXPECT_TRUE(result.success);
    EXPECT_GT(result.exclusionsWritten, 0);
    
    // Verify files were created
    EXPECT_TRUE(FileUtils::fileExists("test_multi_0.el"));
    EXPECT_TRUE(FileUtils::fileExists("test_multi_1.el"));
    
    // Clean up
    std::remove("test_multi_0.el");
    std::remove("test_multi_1.el");
}